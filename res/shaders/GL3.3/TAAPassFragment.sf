// shadertype=<glsl>
#version 330 core
layout (location = 0) out vec4 uni_TAAPassRT0;

in vec2 TexCoords;

uniform sampler2D uni_lightPassRT0;
uniform sampler2D uni_lastTAAPassRT0;
uniform sampler2D uni_motionVectorTexture;
uniform vec2 uni_renderTargetSize;

void main()
{  	
    vec4 currentColor = texture(uni_lightPassRT0, TexCoords);
    if(currentColor.a == 0.0)
    {
    	discard;
    }
    
		vec2 MotionVector = texture(uni_motionVectorTexture, TexCoords).xy / 2.0;
		vec2 historyTexCoords = TexCoords - MotionVector;
		vec4 historyColor = texture(uni_lastTAAPassRT0, historyTexCoords);
		
		vec3 maxNeighbor = vec3(0.0);
		vec3 minNeighbor = vec3(1.0);
		vec4 neighborColor = vec4(0.0);
		vec3 average = vec3(0.0);
		
		vec3 neighborColorSum = vec3(0.0);
		float validNeighborNum = 0.0;
		
		for (int x = -1; x <= 1; x++) {
			for (int y = -1; y <= 1; y++) {
				vec2 neighborTexCoords = TexCoords + vec2(float(x) / uni_renderTargetSize.x, float(y) / uni_renderTargetSize.y);
				neighborColor = texture(uni_lightPassRT0, neighborTexCoords);
					if (neighborColor.a != 0.0)
					{
						maxNeighbor = max(maxNeighbor, neighborColor.rgb);
						minNeighbor = min(minNeighbor, neighborColor.rgb);
						neighborColorSum += neighborColor.rgb;
						validNeighborNum += 1.0;
					}
				}
			}
			average = neighborColorSum / validNeighborNum;
									
      historyColor.rgb = clamp(historyColor.rgb, minNeighbor, maxNeighbor);
			float subpixelCorrection = fract(max(abs(MotionVector.x)*uni_renderTargetSize.x, abs(MotionVector.y)*uni_renderTargetSize.y));
      float contrast = distance(average, currentColor.rgb);		
      float weight = clamp(mix(1.0, contrast, subpixelCorrection) * 0.05, 0.0, 1.0);
      vec3 finalColor = mix(historyColor.rgb, currentColor.rgb, weight);
      
    // sharpen the TAA result [Siggraph 2016 "Temporal Antialiasing in Uncharted 4"]
	  vec2 neighborTexCoordsUp = TexCoords + vec2(0.0f, 1.0f / uni_renderTargetSize.y);
	  vec2 neighborTexCoordsDown = TexCoords + vec2(0.0f, -1.0f / uni_renderTargetSize.y);
	  vec2 neighborTexCoordsLeft = TexCoords + vec2(1.0f / uni_renderTargetSize.x, 0.0f);
	  vec2 neighborTexCoordsRight = TexCoords + vec2(-1.0f / uni_renderTargetSize.x, 0.0f);
	  
	  average = vec3(0.0);
	  validNeighborNum = 0.0;
	  
		vec4 neighborColorUp = texture(uni_lastTAAPassRT0, neighborTexCoordsUp);
		if(neighborColorUp.a != 0.0)
		{
			average -= neighborColorUp.rgb;
			validNeighborNum += 1.0;
		}
		vec4 neighborColorDown = texture(uni_lastTAAPassRT0, neighborTexCoordsDown);
		if(neighborColorDown.a != 0.0)
		{
			average -= neighborColorDown.rgb;
			validNeighborNum += 1.0;
		}		
		vec4 neighborColorLeft = texture(uni_lastTAAPassRT0, neighborTexCoordsLeft);
		if(neighborColorLeft.a != 0.0)
		{
			average -= neighborColorLeft.rgb;
			validNeighborNum += 1.0;
		}		
		vec4 neighborColorRight = texture(uni_lastTAAPassRT0, neighborTexCoordsRight);
		if(neighborColorRight.a != 0.0)
		{
			average -= neighborColorRight.rgb;
			validNeighborNum += 1.0;
		}		

		//finalColor = finalColor + average + finalColor * validNeighborNum;
		
		uni_TAAPassRT0 = vec4(finalColor, 1.0);
}
