// shadertype=glsl
#version 330 core
layout (location = 0) out vec4 uni_lightPassRT0;

in vec2 TexCoords;

struct dirLight {
	vec3 position;
	vec3 direction;
    vec3 color;
};

struct pointLight {
	vec3 position;
	float radius;
    vec3 color;
};

const float PI = 3.14159265359;
const int NR_POINT_LIGHTS = 64;
const int NR_CSM_SPLITS = 4;
const float MAX_REFLECTION_LOD = 4.0;
bool uni_drawCSMSplitedArea = false;

uniform sampler2D uni_geometryPassRT0;
uniform sampler2D uni_geometryPassRT1;
uniform sampler2D uni_geometryPassRT2;
uniform sampler2D uni_geometryPassRT4;
uniform sampler2D uni_geometryPassRT5;
uniform sampler2D uni_geometryPassRT6;
uniform sampler2D uni_geometryPassRT7;

uniform sampler2D uni_shadowMap_0;
uniform sampler2D uni_shadowMap_1;
uniform sampler2D uni_shadowMap_2;
uniform sampler2D uni_shadowMap_3;
uniform float uni_shadowSplitPoints[NR_CSM_SPLITS];
uniform vec4 uni_shadowSplitAreas[NR_CSM_SPLITS];

uniform samplerCube uni_irradianceMap;
uniform samplerCube uni_preFiltedMap;
uniform sampler2D uni_brdfLUT;

uniform vec3 uni_viewPos;
uniform int uni_shadingMode = 0;
uniform dirLight uni_dirLight;
uniform pointLight uni_pointLights[NR_POINT_LIGHTS];

uniform bool uni_isEmissive;

// Oren-Nayar diffuse BRDF [https://github.com/glslify/glsl-diffuse-oren-nayar]
// ----------------------------------------------------------------------------
float orenNayarDiffuse(float LdotV,  float NdotL, float NdotV, float roughness) 
{
  float s = LdotV - NdotL * NdotV;
  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));

  float sigma2 = roughness * roughness;
  float A = 1.0 - (0.5 * sigma2 / (sigma2 + 0.33));
  float B = 0.45 * sigma2 / (sigma2 + 0.09);

  return max(0.0, NdotL) * (A + B * s / t);
}

// Frostbite Engine model [https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf]
// ----------------------------------------------------------------------------
// punctual light attenuation
// ----------------------------------------------------------------------------
float smoothDistanceAtt(float squaredDistance, float invSqrAttRadius)
{
	float factor = squaredDistance * invSqrAttRadius;
	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
	return smoothFactor * smoothFactor;
}
float getDistanceAtt(vec3 unormalizedLightVector, float invSqrAttRadius)
{
	float sqrDist = dot(unormalizedLightVector, unormalizedLightVector);
	float attenuation = 1.0 / (max(sqrDist, 0.0001));
	attenuation *= smoothDistanceAtt(sqrDist, invSqrAttRadius);

	return attenuation;
}
// Specular Fresnel Component
// ----------------------------------------------------------------------------
vec3 fr_F_Schlick(vec3 f0, float f90, float u)
{
	return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
}
// Diffuse BRDF
// ----------------------------------------------------------------------------
float fd_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
{	
	float energyBias = mix(0, 0.5, linearRoughness);
	float energyFactor = mix(1.0, 1.0/1.51, linearRoughness);
	float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness;
	vec3 f0 = vec3 (1.0, 1.0, 1.0);
	float lightScatter = fr_F_Schlick(f0, fd90, NdotL).r;
	float viewScatter = fr_F_Schlick(f0, fd90, NdotV).r;
	return lightScatter * viewScatter * energyFactor;
}
// Specular Geometry Component
// ----------------------------------------------------------------------------
float fr_G_SmithGGXCorrelated(float NdotL , float NdotV , float alphaG)
{
	float alphaG2 = alphaG * alphaG;
	float Lambda_GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaG2) + alphaG2);
	float Lambda_GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaG2) + alphaG2);
	return 0.5 / (Lambda_GGXV + Lambda_GGXL);
}
// Specular Distribution Component
// ----------------------------------------------------------------------------
float fr_D_GGX(float NdotH , float roughness)
{
	// remapping to Quadratic curve
  float a = roughness * roughness;
	float a2 = a * a;
	float f = ( NdotH * a2 - NdotH ) * NdotH + 1;
	return a2 / pow(f, 2.0);
}
// Unreal Engine model [https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf]
// ----------------------------------------------------------------------------
// Specular Distribution Component
// ----------------------------------------------------------------------------
float Unreal_DistributionGGX(float NdotH, float roughness)
{
	float a = roughness*roughness;
	// remapping to Quadratic curve
	float a2 = a * a;
	float NdotH2 = NdotH*NdotH;

	float nom   = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = denom * denom;

	return nom / denom;
}
// Specular Geometry Component
// ----------------------------------------------------------------------------
float Unreal_GeometrySchlickGGX(float NdotV, float roughness)
{
	float r = (roughness + 1.0);
	float k = (r*r) / 8.0;

	float nom   = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	return nom / denom;
}
// ----------------------------------------------------------------------------
float Unreal_GeometrySmith(float NdotV, float NdotL, float roughness)
{
	float ggx2 = Unreal_GeometrySchlickGGX(NdotV, roughness);
	float ggx1 = Unreal_GeometrySchlickGGX(NdotL, roughness);

	return ggx1 * ggx2;
}
// ----------------------------------------------------------------------------
vec3 AverangeFresnel(vec3 F0)
{
	return 20.0 * F0 / 21.0  + 1.0 / 21.0;
}
float getFrMS(float NdotV, float NdotL, vec3 albedo, float roughness)
{
	float frMS = 0.0;
	return frMS;
}
// ----------------------------------------------------------------------------
vec3 CalcDirectionalLightRadiance(dirLight light, vec3 albedo, float metallic, float roughness, vec3 normal, vec3 viewPos, vec3 fragPos, vec3 F0)
{
	vec3 N = normalize(normal);
	vec3 L = normalize(-light.direction);
	vec3 V = normalize(viewPos - fragPos);
	vec3 H = normalize(V + L);

	float NdotV = max(dot(N , V), 0.0);
	float LdotH = max(dot(L , H), 0.0);
	float NdotH = max(dot(N , H), 0.0);
	float NdotL = max(dot(N , L), 0.0);

	// Specular BRDF
	float f90 = 1.0;
	vec3 F = fr_F_Schlick(F0, f90, LdotH);
	float G = fr_G_SmithGGXCorrelated(NdotV, NdotL, roughness);
	float D = fr_D_GGX(NdotH, roughness);
	vec3 Fr =  F * D * G;
 	Fr = Fr / max(4.0 * NdotV * NdotL, 0.00001);
 	
	// Diffuse BRDF
	vec3 Fd = fd_DisneyDiffuse(NdotV, NdotL, LdotH ,roughness * roughness) * albedo; 

	return (Fd + Fr) * light.color * NdotL / PI;		
}
// ----------------------------------------------------------------------------
vec3 CalcPointLightRadiance(pointLight light, vec3 albedo, float metallic, float roughness, vec3 normal, vec3 viewPos, vec3 fragPos, vec3 F0)
{
  vec3 unormalizedL = light.position - fragPos;
	if(length(unormalizedL) < light.radius)
	{
		vec3 N = normalize(normal);
		vec3 L = normalize(unormalizedL);
		vec3 V = normalize(viewPos - fragPos);
		vec3 H = normalize(V + L);

		float NdotV = max(dot(N , V), 0.0);
		float LdotH = max(dot(L , H), 0.0);
		float NdotH = max(dot(N , H), 0.0);
		float NdotL = max(dot(N , L), 0.0);

		// Specular BRDF
		float f90 = 1.0;
		vec3 F = fr_F_Schlick(F0, f90, LdotH);
		float G = fr_G_SmithGGXCorrelated(NdotV, NdotL, roughness);
		float D = fr_D_GGX(NdotH, roughness);
		vec3 Fr = F * D * G;   
    Fr = Fr / max(4.0 * NdotV * NdotL, 0.00001);
    
		// Diffuse BRDF
		vec3 Fd = fd_DisneyDiffuse(NdotV, NdotL, LdotH, roughness * roughness) * albedo;    

    float attenuation = 1.0;
    float invSqrAttRadius = 1.0 / max(light.radius * light.radius, 0.0001);
    attenuation *= getDistanceAtt(unormalizedL, invSqrAttRadius);    
    vec3 radiance = light.color * attenuation;

		return (Fd + Fr) * radiance * NdotL / PI;	
	}
	else
	{
		return vec3(0.0f, 0.0f, 0.0f);
	}
}
// IBL
// corrected Fresnel
// ----------------------------------------------------------------------------
vec3 fr_F_SchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
} 
// ----------------------------------------------------------------------------
vec3 imageBasedLight(vec3 albedo, float metallic, float roughness, vec3 normal, float ao, vec3 viewPos, vec3 fragPos, vec3 F0)
{
			//IBL ambient lighting
			vec3 N = normalize(normal);
			vec3 V = normalize(viewPos - fragPos);
			vec3 R = reflect(-V, N);

			float NdotV = max(dot(N, V), 0.0);

			vec3 F = fr_F_SchlickRoughness(NdotV, F0, roughness); 
			vec3 kS = fr_F_Schlick(F0, 1.0, NdotV);
			vec3 kD = 1.0 - kS;
			kD *= 1.0 - metallic;	  
			vec3 irradiance = texture(uni_irradianceMap, N).rgb;
			vec3 diffuse = irradiance * albedo;

			// sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.
			vec3 prefilteredColor = textureLod(uni_preFiltedMap, R, roughness * MAX_REFLECTION_LOD).rgb;    
			vec2 brdf  = texture(uni_brdfLUT, vec2(NdotV, roughness)).rg;
			vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);
			return (kD * diffuse + specular) * ao;
}
// shadow mapping
// ----------------------------------------------------------------------------
float PCF(vec3 projCoords, sampler2D shadowMap, dirLight light, vec3 normal, vec3 viewPos, vec3 fragPos)
{
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;

    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    
    // calculate bias (based on depth map resolution and slope)
    vec3 N = normal;
    vec3 L = normalize(light.position - fragPos);
		float NdotL = max(dot(N , L), 0.0);
    float bias = max(0.05 * (1.0 - NdotL), 0.005);

    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;
    
    return shadow;
}
// ----------------------------------------------------------------------------
float ShadowCalculation(dirLight light, vec3 normal, vec3 viewPos, vec3 fragPos)
{
	vec3 projCoords = vec3(0.0);
	float shadow = 0.0;
	
	int splitIndex = 3;
	for( int i=0; i < NR_CSM_SPLITS; i++ )
  {
        if( fragPos.x >= uni_shadowSplitAreas[i].x && 
            fragPos.z >= uni_shadowSplitAreas[i].y && 
            fragPos.x <= uni_shadowSplitAreas[i].z && 
            fragPos.z <= uni_shadowSplitAreas[i].w )
        {
					splitIndex = i;
        }
  }

	if(splitIndex == 0)
	{
		vec4 gPassRT = texture(uni_geometryPassRT4, TexCoords);
		projCoords = gPassRT.xyz;
		shadow = PCF(projCoords, uni_shadowMap_0, light, normal, viewPos, fragPos);
	}
	else if(splitIndex == 1)
	{
		vec4 gPassRT = texture(uni_geometryPassRT5, TexCoords);
		projCoords = gPassRT.xyz;
		shadow = PCF(projCoords, uni_shadowMap_1, light, normal, viewPos, fragPos);
	}
	else if(splitIndex == 2)
	{
		vec4 gPassRT = texture(uni_geometryPassRT6, TexCoords);
		projCoords = gPassRT.xyz;
		shadow = PCF(projCoords, uni_shadowMap_2, light, normal, viewPos, fragPos);
	}
	else if(splitIndex == 3)
	{
		vec4 gPassRT = texture(uni_geometryPassRT7, TexCoords);
		projCoords = gPassRT.xyz;
		shadow = PCF(projCoords, uni_shadowMap_3, light, normal, viewPos, fragPos);
	}
	else
	{
	  shadow = 0.0;
	}
        
    return shadow;
}

// ----------------------------------------------------------------------------
void main()
{
	vec4 RT0 = texture(uni_geometryPassRT0, TexCoords);
	vec4 RT1 = texture(uni_geometryPassRT1, TexCoords);
	vec4 RT2 = texture(uni_geometryPassRT2, TexCoords);
		
	uni_lightPassRT0 = vec4(0.0, 0.0, 0.0, 0.0);
		vec3 FragPos	= RT0.rgb;
		vec3 Normal		= RT1.rgb;
		vec3 Albedo     = RT2.rgb;
								
		float Metallic  = RT0.a;
		float Roughness = RT1.a;
		float AO        = RT2.a;
		
		vec3 Lo = vec3(0.0);
				
		if(uni_isEmissive)
		{
			Lo = Albedo;
		}
		else
		{
			vec3 F0 = vec3(0.04); 
			F0 = mix(F0, Albedo, Metallic);

			Lo += CalcDirectionalLightRadiance(uni_dirLight, Albedo, Metallic, Roughness, Normal, uni_viewPos, FragPos, F0);
	    //shadow by directional light
			//Lo *= 1 - ShadowCalculation(uni_dirLight, Normal, uni_viewPos, FragPos);
			for(int i = 0; i < NR_POINT_LIGHTS; ++i) 
			{
				Lo += CalcPointLightRadiance(uni_pointLights[i], Albedo, Metallic, Roughness, Normal, uni_viewPos, FragPos, F0);
			}
		}
	if(uni_drawCSMSplitedArea)		
	{	
		int splitIndex = NR_CSM_SPLITS;
		for( int i=0; i < NR_CSM_SPLITS; i++ )
    {
        if( FragPos.x >= uni_shadowSplitAreas[i].x && 
            FragPos.z >= uni_shadowSplitAreas[i].y && 
            FragPos.x <= uni_shadowSplitAreas[i].z && 
            FragPos.z <= uni_shadowSplitAreas[i].w )
        {
					splitIndex = i;
        }
    }

		if(splitIndex == 0)
		{
			Lo.r += 0.1;
		}
		else if(splitIndex == 1)
		{
			Lo.r += 0.1;
			Lo.g += 0.1;
		}
		else if(splitIndex == 2)
		{
			Lo.g += 0.1;
		}
		else if(splitIndex == 3)
		{
			Lo.b += 0.1;
		}
		else
		{
			Lo.r += 0.1;
			Lo.g += 0.1;
			Lo.b += 0.1;
		}
	}
	uni_lightPassRT0.rgb = Lo;
	uni_lightPassRT0.a = 1.0;
}
